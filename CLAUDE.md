# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This repository is a Talos Kubernetes cluster template that uses Makejinja to render Flux, Talos, and bootstrap configurations from YAML templates. The cluster includes Cilium CNI, Cert-Manager, External-DNS, Cloudflared tunnels, and GitOps via Flux.

## Core Architecture

**Template-Driven Configuration**
- `cluster.yaml` and `nodes.yaml` are the single source of truth for cluster parameters (IPs, DNS, Cloudflare settings)
- `templates/` contains Makejinja source templates that generate manifests in `kubernetes/`, `talos/`, and `bootstrap/`
- SOPS encrypts secrets using Age keys (`age.key`) per `.sops.yaml` configuration
- After initial setup, run `task template:tidy` to archive templating artifacts

**Directory Structure**
- `kubernetes/apps/` - Application HelmReleases and Kustomizations managed by Flux
- `kubernetes/components/` - Core cluster components (Cilium, Cert-Manager)
- `kubernetes/flux/` - Flux system configuration and GitRepository sources
- `talos/` - Talos machine configs generated by talhelper from `talconfig.yaml`
- `bootstrap/` - Helmfile bootstrap manifests applied before Flux takes over
- `scripts/` - Shared shell utilities called by Task targets; extend `scripts/lib` rather than duplicating logic

**GitOps Workflow**
- Flux watches the repository branch (default: main) defined in `cluster.yaml`
- All Kubernetes manifests under `kubernetes/` are synced via Kustomizations
- Secrets are stored encrypted with SOPS; Flux decrypts at apply time
- Use `task reconcile` to force Flux to pull latest Git state

## Essential Commands

**Toolchain Setup**
```sh
mise trust
pip install pipx
mise install          # Install all tools from .mise.toml
```

**Initial Configuration**
```sh
task init             # Generate age key, GitHub deploy key, sample configs
task configure        # Validate schemas, render manifests, encrypt secrets
```

**Bootstrap & Deployment**
```sh
task bootstrap:talos  # Install Talos on nodes
task bootstrap:apps   # Deploy Cilium, CoreDNS, Spegel, Flux
```

**Cluster Management**
```sh
task reconcile                           # Force Flux to sync Git state
task talos:generate-config               # Regenerate Talos configs from talconfig.yaml
task talos:apply-node IP=<ip> MODE=auto  # Apply config to specific node
task talos:upgrade-node IP=<ip>          # Upgrade Talos version on node
task talos:upgrade-k8s                   # Upgrade Kubernetes version
task talos:reset                         # Reset cluster to maintenance mode (destructive)
```

**Debugging**
```sh
task template:debug   # Show certificates, GitRepos, HelmReleases, HTTPRoutes, nodes, pods
flux check            # Verify Flux status
flux get ks -A        # Check Kustomization status
flux get hr -A        # Check HelmRelease status
cilium status         # Verify Cilium CNI
```

## Configuration Files

**cluster.yaml**
- Network CIDRs: `node_cidr`, `cluster_pod_cidr`, `cluster_svc_cidr`
- Load balancer IPs: `cluster_api_addr`, `cluster_dns_gateway_addr`, `cluster_gateway_addr`, `cloudflare_gateway_addr`
- Repository: `repository_name` (GitHub org/repo)
- Cloudflare: `cloudflare_domain`, `cloudflare_token`

**nodes.yaml**
- Per-node definitions with hostname, IP, MAC, control plane role
- Talos schematic ID from factory.talos.dev

**talenv.yaml**
- `talosVersion` and `kubernetesVersion` for upgrades

## Secrets Management

- Age key in `age.key` (referenced by `SOPS_AGE_KEY_FILE`)
- SOPS config in `.sops.yaml` defines encryption rules for `*.sops.*` files
- Never commit unencrypted secrets; `task configure` encrypts all `*.sops.*` files
- Remove `~/.config/sops/age/keys.txt` if it conflicts with repository Age key
- `cloudflare-tunnel.json` contains tunnel credentials (not encrypted by default)
- `github-deploy.key` is the SSH key for Flux repository access (add public key to GitHub deploy keys for private repos)

## Development Workflow

1. Modify `cluster.yaml` or `nodes.yaml` as needed
2. Run `task configure` to render and validate all manifests
3. Verify encrypted files: `find . -name '*.sops.*' -exec sops filestatus {} \;`
4. Commit changes: `git add -A && git commit -m "chore: update config" && git push`
5. Apply to cluster: `task reconcile` (or wait for Flux auto-sync)

## Validation & Standards

- Schema validation via CUE: `.taskfiles/template/resources/*.schema.cue`
- Kubernetes manifest validation: `kubeconform.sh` in configure task
- Talos config validation: `talhelper validate` in configure task
- EditorConfig: 2-space YAML, LF line endings
- Shellcheck: `.shellcheckrc` enforces shell script standards
- Never push unencrypted `*.sops.*` files

## Gateway & DNS

- `envoy-internal` gateway for cluster-internal HTTPRoutes (via `cluster_gateway_addr`)
- `envoy-external` gateway for public HTTPRoutes (via `cloudflare_gateway_addr`)
- k8s_gateway provides DNS at `cluster_dns_gateway_addr` for split-horizon DNS
- Configure home DNS server to forward `cloudflare_domain` queries to `cluster_dns_gateway_addr`

**Multi-Domain Support**: The cluster supports hosting multiple domains (e.g., `primary.com`, `secondary.com`) with automatic DNS and SSL certificate management. For detailed guidance on adding secondary domains, DNS configuration, certificate setup, and troubleshooting, see `docs/docs/notes/adding-a-2nd-domain.md`.

**Critical for Second Domain Apps**: Apps on secondary domains require explicit `DNSEndpoint` resources instead of relying on HTTPRoute annotations due to external-dns `--gateway-name` filter behavior. Gateway certificates must also be configured for each domain. See multi-domain documentation for complete implementation details.

## Updating Configuration

After modifying `talconfig.yaml` or patches:
```sh
task talos:generate-config
task talos:apply-node IP=<node-ip> MODE=auto
```

Some config changes require Talos upgrade to apply:
```sh
task talos:upgrade-node IP=<node-ip>
```

Kubernetes version upgrades:
```sh
# Update kubernetesVersion in talenv.yaml first
task talos:upgrade-k8s
```

## Flux Webhook

To enable push-triggered reconciliation:
1. Get webhook path: `kubectl -n flux-system get receiver github-webhook -o jsonpath='{.status.webhookPath}'`
2. Create GitHub webhook at `https://flux-webhook.${cloudflare_domain}${webhookPath}`
3. Secret: contents of `github-push-token.txt`
4. Content type: `application/json`, Events: push

## Makejinja Plugin

The template engine uses a custom Python plugin at `templates/scripts/plugin.py` that provides filters and functions for rendering Kubernetes manifests. Refer to existing templates for usage patterns.

## Code Quality Principles

**Low Cognitive Complexity**

Write code optimized for human brain processing (max 4 concepts at once):

- **Extract complex conditions** into intermediate variables with meaningful names:
  ```bash
  # ✗ Bad: Overloads working memory
  if [[ "$val" -gt 10 ]] && ([[ "$cond2" == "true" ]] || [[ "$cond3" == "true" ]]) && [[ "$cond4" == "true" ]] && [[ "$cond5" != "true" ]]; then

  # ✓ Good: Cognitive load stays manageable
  is_valid="$([[ "$val" -gt 10 ]] && echo true || echo false)"
  is_allowed="$([[ "$cond2" == "true" ]] || [[ "$cond3" == "true" ]] && echo true || echo false)"
  is_secure="$([[ "$cond4" == "true" ]] && [[ "$cond5" != "true" ]] && echo true || echo false)"

  if [[ "$is_valid" == "true" ]] && [[ "$is_allowed" == "true" ]] && [[ "$is_secure" == "true" ]]; then
  ```

- **Prefer early returns** over nested ifs (free working memory by focusing on happy path only):
  ```bash
  # ✗ Bad: Deep nesting
  function process() {
    if [[ -f "$file" ]]; then
      if [[ -r "$file" ]]; then
        if [[ -s "$file" ]]; then
          # ... actual work 20 lines deep
        fi
      fi
    fi
  }

  # ✓ Good: Early returns keep logic flat
  function process() {
    if [[ ! -f "$file" ]]; then
      log error "File not found" "path=$file"
    fi
    if [[ ! -r "$file" ]]; then
      log error "File not readable" "path=$file"
    fi
    if [[ ! -s "$file" ]]; then
      log error "File empty" "path=$file"
    fi

    # ... actual work at top level (easy to follow)
  }
  ```

- **Write WHY comments, not WHAT comments** (code shows what; comments explain motivation):
  ```yaml
  # ✗ Bad: Duplicates code
  # Set interval to 1 hour
  interval: 1h

  # ✓ Good: Explains motivation
  # WHY: Frequent reconciliation (1h) catches config drift quickly
  # without overloading Git API (15m would hit rate limits)
  interval: 1h
  ```

- **Deep modules over shallow modules** (simple interface, complex implementation is better than complex interface, simple implementation):
  ```bash
  # ✗ Bad: Shallow (complex interface, trivial implementation)
  function get_namespace() { echo "$1"; }
  function get_app() { echo "$2"; }
  function build_path() { echo "kubernetes/apps/$1/$2"; }

  # ✓ Good: Deep (simple interface, complex internals)
  function get_app_path() {
    local namespace="$1"
    local app="$2"
    local base_dir="${ROOT_DIR}/kubernetes/apps"

    # ... validation, error handling, defaults ...

    echo "${base_dir}/${namespace}/${app}"
  }
  ```

## Security and Safety Requirements

**Never Commit Secrets**

- Always run `task configure` before committing (encrypts all `*.sops.*` files)
- Verify encryption status: `find . -name '*.sops.*' -exec sops filestatus {} \;`
- Never commit: `age.key`, `github-deploy.key`, `*.sops.yaml` (unencrypted)
- Never log secret values in scripts (log file paths, not contents)

**Never Perform Destructive Operations Without Explicit Confirmation**

Destructive operations require explicit user approval:

- `task talos:reset` - **DESTRUCTIVE**: Deletes all cluster data
- `task template:reset` - **DESTRUCTIVE**: Deletes all rendered configs
- `kubectl delete namespace` - **DESTRUCTIVE**: Removes namespace and all resources
- `talosctl reset` - **DESTRUCTIVE**: Wipes node data

**Safety checklist before destructive operations**:
1. Verify correct kubeconfig context: `kubectl config current-context`
2. Verify correct Talos context: `talosctl config info`
3. Backup critical data (etcd snapshots, PV data)
4. Confirm intent explicitly (don't automate destructive operations)

**Read-Only Operations by Default**

Prefer read-only commands when investigating:
- `kubectl get` over `kubectl apply`
- `kubectl describe` over `kubectl edit`
- `talosctl get` over `talosctl apply`
- `--dry-run=client` for validation without applying

## Nested Context Files

Detailed guidance for specific subsystems:

- **kubernetes/apps/CLAUDE.md** - How to add Flux-managed applications (3-file pattern, variable substitution)
- **bootstrap/CLAUDE.md** - Bootstrap vs Flux decision tree (when to use helmfile vs Flux)
- **kubernetes/apps/network/CLAUDE.md** - Network stack architecture (gateways, DNS, Cloudflare tunnel)
- **scripts/CLAUDE.md** - Shell script conventions (error handling, logging, reusable functions)
- **.taskfiles/CLAUDE.md** - Task workflow map (init → configure → bootstrap → manage)

Read these nested context files for detailed subsystem-specific guidance.
